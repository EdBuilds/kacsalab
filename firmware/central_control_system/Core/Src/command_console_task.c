/*
 * command_console_task.c
 *
 *  Created on: Aug 5, 2021
 *      Author: tamas
 */
#include "stdbool.h"
#include "cmsis_os2.h"
#include "SEGGER_RTT.h"
#include "FreeRTOS_CLI.h"
#include "string.h"
#include "console_commands.h"

#define ANSI_COLOR_RED     "\x1b[31m"
#define ANSI_COLOR_GREEN   "\x1b[32m"
#define ANSI_COLOR_YELLOW  "\x1b[33m"
#define ANSI_COLOR_BLUE    "\x1b[34m"
#define ANSI_COLOR_MAGENTA "\x1b[35m"
#define ANSI_COLOR_CYAN    "\x1b[36m"
#define ANSI_COLOR_RESET   "\x1b[0m"

#define MAX_OUTPUT_LENGTH (1023U)
#define MAX_INPUT_LENGTH (64U)
static const unsigned terminal_buffer_idx = 0;

void start_command_console_task(void *argument)
{
	char cRxedChar = 0;
	uint16_t cInputIndex = 0;
	BaseType_t xMoreDataToFollow;
	/* The input and output buffers are declared static to keep them off the stack. */
	static char pcOutputString[ MAX_OUTPUT_LENGTH ], pcInputString[ MAX_INPUT_LENGTH ];

	const ERRORS_return_t command_register_result = register_console_commands();

	    /* Send a welcome message to the user knows they are connected. */
    SEGGER_RTT_WriteString(terminal_buffer_idx,
    		"    __ __ ___   ___________ ___    __    ___    ____ \n");
    SEGGER_RTT_WriteString(terminal_buffer_idx,
    		"   / //_//   | / ____/ ___//   |  / /   /   |  / __ )\n");
    SEGGER_RTT_WriteString(terminal_buffer_idx,
    		"  / ,<  / /| |/ /    \\__ \\/ /| | / /   / /| | / __  |\n");
    SEGGER_RTT_WriteString(terminal_buffer_idx,
    		" / /| |/ ___ / /___ ___/ / ___ |/ /___/ ___ |/ /_/ / \n");
    SEGGER_RTT_WriteString(terminal_buffer_idx,
    		"/_/ |_/_/  |_\\____//____/_/  |_/_____/_/  |_/_____/  \n");
    SEGGER_RTT_WriteString(terminal_buffer_idx, "\n");
    SEGGER_RTT_WriteString(terminal_buffer_idx,"Central Control System shell interface\n");
    SEGGER_RTT_WriteString(terminal_buffer_idx,"Enter 'help' to view a list of available commands.\n");

    if (command_register_result != ERRORS_ok) {
    	SEGGER_RTT_WriteString(terminal_buffer_idx,"Could not register tasks!\n");
    	// TODO: error handling
    }
	    for( ;; )
	    {
	        /* This implementation reads a single character at a time.  Wait in the
	        Blocked state until a character is received. */
	        const uint32_t read_chars_num = SEGGER_RTT_ReadNoLock(terminal_buffer_idx, &cRxedChar, sizeof(cRxedChar));

	        if (read_chars_num == sizeof(cRxedChar)) {

	            if( cRxedChar == '\n' ) {
	                /* A newline character was received, so the input command string is
	                complete and can be processed.  Transmit a line separator, just to
	                make the output easier to read. */
	                SEGGER_RTT_WriteString(terminal_buffer_idx, "\r\n");

	                /* The command interpreter is called repeatedly until it returns
	                pdFALSE.  See the "Implementing a command" documentation for an
	                exaplanation of why this is. */
	                do
	                {
	                    /* Send the command string to the command interpreter.  Any
	                    output generated by the command interpreter will be placed in the
	                    pcOutputString buffer. */
	                    xMoreDataToFollow = FreeRTOS_CLIProcessCommand
	                                  (
	                                      pcInputString,   /* The command string.*/
	                                      pcOutputString,  /* The output buffer. */
	                                      MAX_OUTPUT_LENGTH/* The size of the output buffer. */
	                                  );

	                    /* Write the output generated by the command interpreter to the
	                    console. */
	                    SEGGER_RTT_WriteString(terminal_buffer_idx, pcOutputString);

	                } while( xMoreDataToFollow != pdFALSE );

	                /* All the strings generated by the input command have been sent.
	                Processing of the command is complete.  Clear the input string ready
	                to receive the next command. */
	                cInputIndex = 0;
	                memset( pcInputString, 0x00, MAX_INPUT_LENGTH );

	            } else {
	                /* The if() clause performs the processing after a newline character
	                is received.  This else clause performs the processing if any other
	                character is received. */

	                if( cRxedChar == '\r' )
	                {
	                    /* Ignore carriage returns. */
	                }
	                else if( cRxedChar == '\b' )
	                {
	                    /* Backspace was pressed.  Erase the last character in the input
	                    buffer - if there are any. */
	                    if( cInputIndex > 0 )
	                    {
	                        cInputIndex--;
	                        pcInputString[ cInputIndex ] = '\0';
	                    }
	                }
	                else
	                {
	                    /* A character was entered.  It was not a new line, backspace
	                    or carriage return, so it is accepted as part of the input and
	                    placed into the input buffer.  When a n is entered the complete
	                    string will be passed to the command interpreter. */
	                    if( cInputIndex < MAX_INPUT_LENGTH )
	                    {
	                        pcInputString[ cInputIndex ] = cRxedChar;
	                        cInputIndex++;
	                    }
	                }
	            }
	        } else {
	        	osDelay(100);
	        }
	    }
}
